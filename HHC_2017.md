# Holiday Hack Challenge 2017!

This is my writeup for the holiday hack
challenge 2017... Let's go!

## Question's

1. Visit the North Pole and Beyond at the 
Winter Wonder Landing Level to collect the 
first page of The Great Book using a giant snowball.
What is the title of that page?

Answer: About this book...

SHA1: 6dda7650725302f59ea42047206bd4ee5f928d19

2. Investigate the Letters to Santa application at
https://l2s.northpolechristmastown.com. What is the
topic of The Great Book page available in the web root of the
server? What is Alabaster Snowball's password?

Answer: The topic of the GreatBookPage2.pdf is about flying animals
like the flying monkeys of Oz and the flying reindeer of Santa
The password for Alabaster is stream_unhappy_buy_loss

SHA1: aa814d1c25455480942cb4106e6cde84be86fb30

3. The North Pole engineering team uses a Windows SMB server for
sharing documentation and correspondence. Using your access to
the Letters to Santa server, identify and enumerate the SMB
file-sharing server. What is the file server share name? 

Answer: Name of the share is FileStor

SHA1: 57737da397cbfda84e88b573cd96d45fcf34a5da

## Sn0wBallz

Well, what is there to say. I actually began
to like the snowball game but have to admit
it had me frustrated in the beginning, which is why
I did as much CranPi terminals before doing the game.

The more terminals you crack, the more usables you get
for deflecting the snowball to the end. really fun actually.

Yes, I did all the snowball quests.

## Terminals

### Winter Wonder Landing
To be honoust it took me a while before I 
figured out the mechanics of the snowball game.
So first I went with all terminals. first terminal
I took down was the one in the Winter Wonder Landing
level. 
The find command from the $PATH was the wrong one,
so just running "whereis find" shows us to run find
from /usr/bin/find and not /usr/local/bin/find.
```shell
$ /usr/bin/find / -name elftalkd 2> /dev/null
/run/elftalk/bin/elftalkd <-- hello there! ;-P
```

### Winconceivable: The cliffs of Winsanity
We have to kill the 'santaslittlehelperd' process.

Reading up on the twitter of Sparkle Redberry
led me to believe that this had something to do with
aliases. Let's check the shell's .bashrc file.
```shell
$ grep -i 'alias' .bashrc
alias kill='true'
alias killall='true'
alias pkill='true'
...
```

So yes, when we run kill we are actually running true,
which is not capable of killing processes... let's kill
the requested proces
```shell
$ /bin/kill -9 $(pidof santaslittlehelperd)
```

### There's snow place like home
We need to run the trainstartup binary.
```shell
$ file trainstartup
trainstartup: ELF 32-bit LSB  executable, ARM, EABI5 ...\<snip\>...
```
Okay, it is an ARM 32 bit executable, but we are on x64.
```shell
$ uname -p
x86_64
```

tab completion showed me that there is a full install of qemu.
Running 'qemu-arm trainstartup' gives us a nice ASCIImation and
completes the challenge.

### Cryokinetic Magic
I really liked this challenge, 
learned a very neat trick, thanks guys!

We have to run an executable in our home folder,
owned by root and no execute bit is set. Should be
simple enough, I copied the program and used chmod to set the
execute bit. It didn't work, another utility that has been
tampered with... 

Being clueless I went to the Twitter page of
the elf to look for hints and read some really cool blogpost
about using the LD_PRELOAD environment variable to trick a binary
in using your self defined functions. This didn't work here because 
we can't trace which functions the binary calls.

A post on superuser linked to by the twitter gave another great
technique; using ld-linux as an ELF interpreter. let's find this file.
```shell
$ find / -name "ld-linux\*" 2>/dev/null
/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
/lib64/ld-linux-x86-64.so.2

$ ls -l /lib64/ld-linux-x86-64.so.2
lrwxrwxrwx 1 root root 32 Jun 16 20:57 /lib64/ld-linux-x86-64.so.2 -> /lib/x86_64-linux-gnu/ld-2.23.so
```
Let's use that to run the executable
```shell
$ /lib/x86_64-linux-gnu/ld-2.23.so $(pwd)/CandyCaneStriper
```

Nice ASCII art and done ;-D.

### Bumbles bounce
We have to find the least-popular browser by
checking an access log in the homefolder.

We can use awk to take a specific field (delimited
by spaces) and put that into sort and uniq to find the
browser given in the user agent that accessed the server.

Counting the fields shows that the 12th field contains
the name of the browser, so we will use awk to only print
this field, sort the output and use uniq with the -c switch
to prepend the count to the unique lines in the output.
```shell
$ awk '{print $12}' < access.log | sort | uniq -c
    47 
      2 "(KHTML,
     90 "-"
      1 "Dillo/3.0.5"
      3 "GarlikCrawler/1.2
     34 "Googlebot-Image/1.0"
      3 "MobileSafari/604.1
    357 "Mozilla/4.0
  97534 "Mozilla/5.0
.....
```

Hmmm... the most used one is Mozilla/5.0, some of the least used
user agents aren't even webbrowsers but crawlers like Googlebot,
Twitterbot etc. But what is Dillo? Well, Dillo is the least popular
webbrowser it seems.

Maybe this is not the intended way, but it worked for me.

### I don't think we're in Kansas anymore
So for this terminal we have to determine the most liked song
inside of a sqlite database.

checking the schema gives us the following:
```shell
sqlite> .schema
CREATE TABLE songs(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  artist TEXT,
  year TEXT,
  notes TEXT
);
CREATE TABLE likes(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  like INTEGER,
  datetime INTEGER,
  songid INTEGER,
  FOREIGN KEY(songid) REFERENCES songs(id)
);
```
likes.like is an integer that is set to 0 or 1
to determine wheter or not a specific song has a like

lets find the song with the most likes with by looking for
the songid with the most entries and the likes.like set to 1

```shell
sqlite> SELECT title, like, songid, COUNT(*) totalcount FROM songs, likes WHERE like = 1 AND songs.id = likes.songid GROUP BY title HAVING COUNT(*) > 1 ORDER BY COUNT(*) ASC;
```

This will throw out a list of songs with the most popular
one at the bottom just above our sqlite> prompt.
The most popular song seems to be stairway to heaven!

### Oh wait! Maybe we are...
We have to restore the contents of the /etc/shadow
file with the contents of /etc/shadow.bak and are given
the hint to check which commands we can run with sudo

```shell
$ sudo -l
...<snip>...
User elf may run the following commands on 44fcbb65bef9:
    (elf : shadow) NOPASSWD: /usr/bin/find
```

So we can run find with the rights of the shadow group, which
also has write access to the /etc/shadow file, making this challenge
fairly easy. We can use the -exec flag of the find command to execute
any bash command that we like.

```shell
$ sudo -g shadow find / -name 'shadow' -exec bash -c 'cat {}.bak > {}' \; 2>/dev/null
```

If we now run the inspect_da_box command it will tell us
that we have succeeded with some ASCII art.

### We're off to see the...
For this challenge we have a binary that uses the rand() libc
function to generate a pseudo-random number and then checks if
that number was 42. We have to force it to return 42 somehow.

I used the dynamic linker technique to substitute the rand() function
with one of my own which just returns the number 42.

```c
int rand(){
	return 42;
}
```

Now all we have to do is make a shared object of this source and load
it with the binary.

```shell
$ gcc -shared -fPIC myrand.c -o myrand.so
$ LD_PRELOAD=$(pwd)/myrand.so ./isit42 
```
This makes the binary use our rand() function and it returns
the number 42, and so we conclude the terminal challanges :-D

## l2s server

In the HTML source of https://l2s.northpolechristmastown.com we can
see a development page called dev.northpolechristmastown.com. going there
and using the hint from sparkle redberry we can see that we have to exploit
the orders.xhtml page. I used the tailored exploit from https://github.com/chrisjd20/cve-2017-9805.py
to place a php shell on the webroot. 

When connecting to my webshell I had a really hard time finding Alabasters password.
reading /etc/passwd gave me his username however: "alabaster_snowball".

After searching for longer than I want to admit I found out that
maybe he stored his password somewere in a development file from a tip
of one of the elves so I started to search in /opt/. Using 
```shell
'find /opt/ -user alabaster_snowball -exec cat {} \;'
```
I found a lot of files belonging to alabaster, but nothing containing a password.

Lets grep the files
```shell
$ cd /opt/ && grep -Hir 'alabaster_snowball'
/opt/apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class:            final String username = "alabaster_snowball";
```
Okay, but i somehow cannot open the whole file, what about
setting some context to our grep output?
```shell
$ cd /opt/ && grep -Hir -C 3 'alabaster_snowball'
/opt/apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class-    public class Connect {
/opt/apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class-            final String host = "localhost";
/opt/apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class:            final String username = "alabaster_snowball";
/opt/apache-tomcat/webapps/ROOT/WEB-INF/classes/org/demo/rest/example/OrderMySql.class-            final String password = "stream_unhappy_buy_loss";   
```

YAY! we got the password

## SMB through l2s server

For the next challenge we have to forward a local port to one
on the internal network through the SSH server.

First I ran an NMap scan in the internal 10.142.0.0/24 network
without ping to scan services within the network to find a host
with SMB on 10.142.0.7. Now we can use port forwarding through
SSH to connect to this fileshare.
```shell
$ ssh -L 4455:10.142.0.7:445 alabaster_snowball@35.185.84.51
```

Then I used my Mac to connect to the fileshare on smb://127.0.0.1:4455
and logged in with alabaster's account to mount the FileStor share.


